// const fs = require("fs");
// const path = require("path");
// const { spawn } = require("child_process");
// const cloudinary = require("cloudinary").v2;

// cloudinary.config({
//     cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
//     api_key: process.env.CLOUDINARY_API_KEY,
//     api_secret: process.env.CLOUDINARY_API_SECRET,
// });

// exports.detectionImg = async (req, res) => {
//     try {
//         if (!req.file) {
//             return res.status(400).json({ error: "No image file provided" });
//         }

//         const imagePath = req.file.path.replaceAll("\\", "/");
//         console.log("üì§ Uploaded image path:", imagePath);

//         const python = spawn("python", ["yolov8/detect.py", imagePath]);

//         let output = "";

//         python.stdout.on("data", (data) => {
//             output += data.toString();
//         });

//         python.stderr.on("data", (data) => {
//             console.error(`stderr: ${data}`);
//         });

//         python.on("close", async (code) => {
//             try {
//                 const detectPath = path.join(process.cwd(), 'runs', 'detect');


//                 if (!fs.existsSync(detectPath)) {
//                     fs.mkdirSync(detectPath, { recursive: true });
//                 }

//                 const subDirs = fs.readdirSync(detectPath)
//                     .map(name => ({
//                         name,
//                         fullPath: path.join(detectPath, name),
//                     }))
//                     .filter(entry => fs.statSync(entry.fullPath).isDirectory())
//                     .sort((a, b) => {
//                         return fs.statSync(b.fullPath).mtimeMs - fs.statSync(a.fullPath).mtimeMs;
//                     })
//                     .map(entry => entry.name); // ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏Ñ‡πà‡∏ä‡∏∑‡πà‡∏≠‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå

//                 const latestDir = subDirs[0];
//                 const resultDirPath = path.join(detectPath, latestDir);

//                 const resultFiles = fs.readdirSync(resultDirPath).filter(file =>
//                     /\.(jpg|jpeg|png|webp)$/i.test(file)
//                 );

//                 if (resultFiles.length === 0) {
//                     throw new Error("No image files found in result folder");
//                 }

//                 const resultImageFile = resultFiles[0];
//                 const resultImgPath = path.join(resultDirPath, resultImageFile);

//                 // ‚¨ÜÔ∏è Upload to Cloudinary
//                 const uploadResult = await cloudinary.uploader.upload(resultImgPath, {
//                     folder: "detections"
//                 });

//                 console.log("üåê Cloudinary URL:", uploadResult.secure_url);


//                 // ‚úÖ ‡∏™‡πà‡∏á response ‡∏Å‡πà‡∏≠‡∏ô
//                 if (!res.headersSent) {
//                     res.json({
//                         result: output.trim(),
//                         imageUrl: uploadResult.secure_url,
//                     });
//                 }

//                 // üßπ ‡∏•‡∏ö‡∏†‡∏≤‡∏û‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ß‡πâ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß
//                 fs.unlink(imagePath, (err) => {
//                     if (err) {
//                         console.error("‚ùå Failed to delete original uploaded image:", err);
//                     } else {
//                         console.log("üßπ Deleted original uploaded image:", imagePath);
//                     }
//                 });

//                 // üßπ ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏•‡∏±‡∏á‡∏™‡πà‡∏á response ‡πÅ‡∏•‡πâ‡∏ß
//                 fs.rm(resultDirPath, { recursive: true, force: true }, (err) => {
//                     if (err) {
//                         console.error("Failed to delete detection result folder:", err);
//                     } else {
//                         console.log("üßπ Deleted detection folder:", resultDirPath);
//                     }
//                 });

//             } catch (err) {
//                 console.error("Error reading detection folder:", err);
//                 if (!res.headersSent) {
//                     res.status(500).json({ error: "Detection folder read failed" });
//                 }
//             }
//         });
//     } catch (error) {
//         console.error("Internal server error:", error);
//         if (!res.headersSent) {
//             res.status(500).json({ error: "Internal server error" });
//         }
//     }
// };

const fs = require("fs");
const path = require("path");
const { spawn } = require("child_process");
const cloudinary = require("cloudinary").v2;

cloudinary.config({
    cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
    api_key: process.env.CLOUDINARY_API_KEY,
    api_secret: process.env.CLOUDINARY_API_SECRET,
});

exports.detectionImg = async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: "No image file provided" });
        }

        const imagePath = req.file.path.replaceAll("\\", "/");
        console.log("üì§ Uploaded image path:", imagePath);

        const python = spawn("python", ["yolov8/detect.py", imagePath]);

        let output = "";
        let errorOutput = "";

        python.stdout.on("data", (data) => {
            const text = data.toString();
            output += text;
            console.log("üêç Python stdout:", text.trim());
        });

        python.stderr.on("data", (data) => {
            const text = data.toString();
            errorOutput += text;
            console.error("üêç Python stderr:", text.trim());
        });

        python.on("close", async (code) => {
            try {
                console.log(`üêç Python process exited with code: ${code}`);
                console.log(`üêç Python stdout output: "${output.trim()}"`);
                console.log(`üêç Python stderr output: "${errorOutput.trim()}"`);
                
                // ‡∏ñ‡πâ‡∏≤ Python ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß
                if (code !== 0) {
                    throw new Error(`Python script failed with exit code ${code}. Error: ${errorOutput.trim() || 'No error message'}`);
                }
                
                // Wait a bit for YOLOv8 to finish writing files
                await new Promise(resolve => setTimeout(resolve, 2000));

                // Try to find where YOLOv8 actually saved the results
                let detectPath = null;
                let resultDirPath = null;
                let resultImgPath = null;

                // Search in multiple possible locations
                const searchPaths = [
                    path.resolve(process.cwd(), 'runs', 'detect'),
                    path.resolve(__dirname, '..', 'runs', 'detect'),
                    path.resolve(__dirname, '..', '..', 'runs', 'detect'),
                    path.resolve('./runs/detect'),
                    path.resolve('./yolov8/runs/detect'),
                    path.resolve(process.cwd(), 'yolov8', 'runs', 'detect'),
                    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
                    path.resolve('/tmp/runs/detect'),
                    path.resolve(process.env.HOME || '/tmp', 'runs', 'detect')
                ];

                console.log("üîç Searching for detection results in multiple paths...");
                
                for (const searchPath of searchPaths) {
                    console.log(`üìÅ Checking: ${searchPath}`);
                    
                    if (fs.existsSync(searchPath)) {
                        try {
                            const dirContents = fs.readdirSync(searchPath);
                            console.log(`üìÇ Contents of ${searchPath}:`, dirContents);
                            
                            const subDirs = dirContents
                                .map(name => ({
                                    name,
                                    fullPath: path.join(searchPath, name),
                                }))
                                .filter(entry => {
                                    try {
                                        return fs.statSync(entry.fullPath).isDirectory();
                                    } catch (err) {
                                        return false;
                                    }
                                })
                                .sort((a, b) => {
                                    try {
                                        return fs.statSync(b.fullPath).mtimeMs - fs.statSync(a.fullPath).mtimeMs;
                                    } catch (err) {
                                        return 0;
                                    }
                                });

                            if (subDirs.length > 0) {
                                detectPath = searchPath;
                                resultDirPath = subDirs[0].fullPath;
                                console.log(`‚úÖ Found detection results at: ${resultDirPath}`);
                                break;
                            }
                        } catch (err) {
                            console.warn(`‚ö†Ô∏è Error reading ${searchPath}:`, err.message);
                        }
                    }
                }

                // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå ‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á‡∏´‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
                if (!resultDirPath) {
                    console.log("üîç No subdirectories found, searching for result files directly...");
                    
                    // ‡∏•‡∏≠‡∏á‡∏´‡∏≤‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
                    const directSearchPaths = [
                        ...searchPaths,
                        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
                        path.dirname(imagePath), // ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö
                        path.resolve(process.cwd()),
                        path.resolve(__dirname, '..'),
                        '/tmp'
                    ];

                    for (const searchPath of directSearchPaths) {
                        if (fs.existsSync(searchPath)) {
                            try {
                                const files = fs.readdirSync(searchPath);
                                const imageFiles = files.filter(file => 
                                    /\.(jpg|jpeg|png|webp)$/i.test(file) && 
                                    file !== path.basename(imagePath) // ‡πÑ‡∏°‡πà‡πÄ‡∏≠‡∏≤‡∏£‡∏π‡∏õ‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö
                                );
                                
                                if (imageFiles.length > 0) {
                                    // ‡∏´‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
                                    const newestFile = imageFiles
                                        .map(file => ({
                                            name: file,
                                            fullPath: path.join(searchPath, file),
                                            mtime: fs.statSync(path.join(searchPath, file)).mtimeMs
                                        }))
                                        .sort((a, b) => b.mtime - a.mtime)[0];
                                    
                                    resultImgPath = newestFile.fullPath;
                                    console.log(`‚úÖ Found result image directly: ${resultImgPath}`);
                                    break;
                                }
                            } catch (err) {
                                console.warn(`‚ö†Ô∏è Error searching ${searchPath}:`, err.message);
                            }
                        }
                    }
                }

                // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ‡∏´‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ô‡∏±‡πâ‡∏ô
                if (resultDirPath && !resultImgPath) {
                    const resultFiles = fs.readdirSync(resultDirPath).filter(file =>
                        /\.(jpg|jpeg|png|webp)$/i.test(file)
                    );

                    if (resultFiles.length === 0) {
                        const allFiles = fs.readdirSync(resultDirPath);
                        throw new Error(`No image files found in result folder ${resultDirPath}. Found files: ${allFiles.join(', ')}`);
                    }

                    resultImgPath = path.join(resultDirPath, resultFiles[0]);
                }

                // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏•‡∏¢
                if (!resultImgPath) {
                    // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• debug ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
                    console.log("üîç Debug Information:");
                    console.log("- Python exit code:", code);
                    console.log("- Python stdout:", output.trim() || "No output");
                    console.log("- Python stderr:", errorOutput.trim() || "No errors");
                    console.log("- Image path:", imagePath);
                    console.log("- Current working directory:", process.cwd());
                    
                    // ‡∏•‡∏≠‡∏á‡∏´‡∏≤‡∏£‡∏π‡∏õ‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
                    const currentDirFiles = fs.readdirSync(process.cwd())
                        .filter(file => /\.(jpg|jpeg|png|webp)$/i.test(file));
                    console.log("- Images in current directory:", currentDirFiles);
                    
                    throw new Error(`No result image found after Python detection. 
                        Exit code: ${code}
                        Python output: "${output.trim() || 'No output'}"
                        Python errors: "${errorOutput.trim() || 'No errors'}"
                        Current directory files: ${currentDirFiles.join(', ')}`);
                }

                console.log("üñºÔ∏è Processing result image:", resultImgPath);

                // Verify the result image exists
                if (!fs.existsSync(resultImgPath)) {
                    throw new Error(`Result image file doesn't exist: ${resultImgPath}`);
                }

                // ‚¨ÜÔ∏è Upload to Cloudinary
                const uploadResult = await cloudinary.uploader.upload(resultImgPath, {
                    folder: "detections"
                });

                console.log("üåê Cloudinary URL:", uploadResult.secure_url);

                // ‚úÖ Send response
                if (!res.headersSent) {
                    res.json({
                        result: output.trim(),
                        imageUrl: uploadResult.secure_url,
                    });
                }

                // üßπ Clean up files after successful response
                cleanup(imagePath, resultDirPath);

            } catch (err) {
                console.error("‚ùå Error in detection processing:", err.message);
                console.error("Full error:", err);
                
                if (!res.headersSent) {
                    res.status(500).json({ 
                        error: "Detection processing failed", 
                        details: err.message 
                    });
                }
                
                // Still try to clean up the original uploaded file
                cleanup(imagePath);
            }
        });

        // Handle python process errors
        python.on('error', (err) => {
            console.error("‚ùå Python process error:", err);
            if (!res.headersSent) {
                res.status(500).json({ 
                    error: "Detection process failed to start", 
                    details: err.message 
                });
            }
        });

    } catch (error) {
        console.error("‚ùå Internal server error:", error);
        if (!res.headersSent) {
            res.status(500).json({ error: "Internal server error" });
        }
    }
};

// Helper function for cleanup
function cleanup(imagePath, resultDirPath = null) {
    // Clean up original uploaded image
    if (imagePath && fs.existsSync(imagePath)) {
        fs.unlink(imagePath, (err) => {
            if (err) {
                console.error("‚ùå Failed to delete original uploaded image:", err);
            } else {
                console.log("üßπ Deleted original uploaded image:", imagePath);
            }
        });
    }

    // Clean up result directory
    if (resultDirPath && fs.existsSync(resultDirPath)) {
        fs.rm(resultDirPath, { recursive: true, force: true }, (err) => {
            if (err) {
                console.error("‚ùå Failed to delete detection result folder:", err);
            } else {
                console.log("üßπ Deleted detection folder:", resultDirPath);
            }
        });
    }
}